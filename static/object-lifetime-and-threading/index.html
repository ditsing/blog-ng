<!DOCTYPE html>
<html lang="en">
<head>

	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

	<title>Object lifetime and threading</title>
	<meta name="HandheldFriendly" content="True" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<link rel="stylesheet" type="text/css" href="/assets/css/style.css?v=b23e0a0900" />

	<script>
			var siteUrl = 'https://www.ditsing.com';
	</script>

	<script>
			var localTheme = localStorage.getItem('attila_theme');
			switch (localTheme) {
					case 'dark':
							document.documentElement.classList.add('theme-dark');
							break;
					case 'light':
							document.documentElement.classList.add('theme-light');
							break;
					default:
							break;
			}
	</script>



			<style>
				.theme-dark:root {
				  --ghost-accent-color: #ff6633;
				}
				@media (prefers-color-scheme: dark) {
				  html:not(.theme-light):root {
				    --ghost-accent-color: #ff6633;
				  }
				}
			</style>

	<link rel="icon" href="/favicon.png" type="image/png" />
    <link rel="canonical" href="https://www.ditsing.com/object-lifetime-and-threading/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="https://www.ditsing.com/object-lifetime-and-threading/amp/" />
    
    <meta property="og:site_name" content="顿" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Object lifetime and threading" />
    <meta property="og:description" content="Last time we talked about object lifetime and ownership. Naturally scopes and objects form a tree hierarchy. The root of the tree is the scope where the program starts executing. Beyond the tree structure, we can pass information between scopes with the help of dynamic lifetime. Dynamic lifetime is hard" />
    <meta property="og:url" content="https://www.ditsing.com/object-lifetime-and-threading/" />
    <meta property="article:published_time" content="2021-09-26T03:05:52.000Z" />
    <meta property="article:modified_time" content="2021-09-28T16:47:39.000Z" />
    <meta property="article:tag" content="Lifetime" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Object lifetime and threading" />
    <meta name="twitter:description" content="Last time we talked about object lifetime and ownership. Naturally scopes and objects form a tree hierarchy. The root of the tree is the scope where the program starts executing. Beyond the tree structure, we can pass information between scopes with the help of dynamic lifetime. Dynamic lifetime is hard" />
    <meta name="twitter:url" content="https://www.ditsing.com/object-lifetime-and-threading/" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Jing Yang 杨靖" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Lifetime" />
    <meta name="twitter:site" content="@dytsing" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "顿",
        "url": "https://www.ditsing.com/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.ditsing.com/content/images/2021/01/hammer_transparent.png"
        }
    },
    "author": {
        "@type": "Person",
        "name": "Jing Yang 杨靖",
        "url": "https://www.ditsing.com/author/ditsing/",
        "sameAs": []
    },
    "headline": "Object lifetime and threading",
    "url": "https://www.ditsing.com/object-lifetime-and-threading/",
    "datePublished": "2021-09-26T03:05:52.000Z",
    "dateModified": "2021-09-28T16:47:39.000Z",
    "keywords": "Lifetime",
    "description": "Last time we talked about object lifetime and ownership. Naturally scopes and\nobjects form a tree hierarchy. The root of the tree is the scope where the\nprogram starts executing. Beyond the tree structure, we can pass information\nbetween scopes with the help of dynamic lifetime. Dynamic lifetime is hard to\nmanage and is also the #1 source of bugs (&quot;use after free&quot;) in C programs. The\nconcept of ownership can simplify many useful cases of dynamic lifetime.\n\nThreads\nThreads make lifetime more comp",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.ditsing.com/"
    }
}
    </script>

    <meta name="generator" content="Ghost 4.47" />
    <link rel="alternate" type="application/rss+xml" title="顿" href="https://www.ditsing.com/rss/" />
    
    <script defer src="/public/cards.min.js?v=b23e0a0900"></script><style>:root {--ghost-accent-color: #15171A;}</style>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=b23e0a0900">
</head>

<body class="post-template tag-lifetime">

	<div class="nav-header">
		<nav class="nav-wrapper" aria-label="Main">
				<span class="logo">
					<a href="https://www.ditsing.com" title="Home"><img src="https://www.ditsing.com/content/images/2021/01/hammer_transparent.png" alt="Logo" /></a>
				</span>
				<ul>
		<li class="nav-home"><a href="https://www.ditsing.com/"><span>Home</span></a></li>
		<li class="nav-the-author"><a href="https://www.ditsing.com/author/"><span>The Author</span></a></li>
		<li class="nav-zhong-wen"><a href="https://www.ditsing.com/tag/cn/"><span>中文</span></a></li>
		<li class="nav-jian-zheng"><a href="https://www.ditsing.com/tag/jian-zheng/"><span>键政</span></a></li>
		<li class="nav-guan-yu"><a href="https://www.ditsing.com/about-me/"><span>关于</span></a></li>
		<li class="nav-jiu-bo"><a href="http://old.ditsing.com"><span>旧博</span></a></li>
</ul>

				<ul class="nav-meta">
  <li class="nav-twitter">
    <a aria-label="Twitter" href="https://twitter.com/dytsing" title="@dytsing" target="_blank">
      <i class="icon icon-twitter" aria-hidden="true"></i>
      <span>@dytsing</span>
    </a>
  </li>
  <li class="nav-github">
    <a aria-label="GitHub" href="https://github.com/ditsing" title="" target="_blank">
      <i class="icon icon-github" aria-hidden="true"></i>
      <span></span>
    </a>
  </li>
  <li class="nav-search" style="display: none;">
    <a title="Search">
      <i class="icon icon-search" aria-hidden="true"></i>
      <span>Search</span>
    </a>
  </li>
  <li class="nav-rss">
    <a title="RSS" href="https://www.ditsing.com/rss/" target="_blank">
      <i class="icon icon-rss" aria-hidden="true"></i>
    </a>
  </li>
  <!--
    <li class="nav-subscribe">
      <a href="#/portal">Subscribe</a>
    </li>
  -->
</ul>
		</nav>

		<div class="nav-wrapper-control">
			<div class="inner">
				<a class="nav-menu" role="button"><i class="icon icon-menu" aria-hidden="true"></i>Menu</a>
				<a class="nav-search" style="display: none;" title="Search" role="button"><i class="icon icon-search" aria-hidden="true"></i></a>
			</div>
		</div>
	</div>
	<div class="nav-close" role="button" aria-label="Close"></div>

	<section class="page-wrapper">

		

<div class="progress-container">
	<span class="progress-bar"></span>
</div>

<header class="post-header ">
	<div class="inner">
		<span class="post-info">
			<span class="post-type">Article</span>
			<span class="post-count">Lifetime</span>
		</span>
		<h1 class="post-title">Object lifetime and threading</h1>
		<div class="post-meta">
			<div class="post-meta-avatars">
					<figure class="post-meta-avatar avatar">
					</figure>
			</div>
			<h4 class="post-meta-author"><a href="/author/ditsing/">Jing Yang 杨靖</a></h4>
			<time datetime="25-09-2021">25 Sep 2021</time> &bull; 4 min read
		</div>
	</div>
</header>

<main class="content" role="main">
	<article class="post tag-lifetime no-image">
		<div class="inner">

			<section class="post-content">
				<p>Last time we talked about object lifetime and ownership. Naturally scopes and objects form a tree hierarchy. The root of the tree is the scope where the program starts executing. Beyond the tree structure, we can pass information between scopes with the help of dynamic lifetime. Dynamic lifetime is hard to manage and is also the #1 source of bugs ("use after free") in C programs. The concept of ownership can simplify many useful cases of dynamic lifetime.</p><h3 id="threads"><strong>Threads</strong></h3><p>Threads make lifetime more complex. We now have several starting points where threads might start executing independently. No assumption can be made about the progress of each thread. At one point in thread A, there is usually no guarantee whether an object in thread B has been initialized/destroyed or not. That makes data sharing between threads extremely difficult. As it turns out, making sure the data is alive while being shared is another hard problem to solve. Doing it wrong, our C program crashes and throws "core dumps" at us. There are many clever ways to guarantee liveness. But we are more interested in the foolproof ways that take advantage of single ownership.</p><h3 id="copy-instead-of-share"><strong>Copy instead of share</strong></h3><p>Sharing implies more than one owner. Multiple owners are hard to coordinate with. Instead of sharing, we make copies of the data for each of the interested parties. Those copies will have independent lifetimes, each owned by one thread. That simplifies the situation because each copy has a single owner.</p><p>In the case of sharing between two parties, the actual copying can be saved if the source (initiator) of sharing does not need the object anymore. Then sharing is reduced to a simple "transfer ownership" operation.</p><p>There are other ways of describing this strategy. We can think of it as sending a message. The source of sharing makes a copy of the shared data, and sends it to the target as a message. A message, by definition, goes out of control of the source  after being sent. The target owns the message after receiving it. An RPC request from the source to the target achieves the same goal.</p><p>The famous paper <em>Communicate Sequential Processes</em> proposed a similar strategy. Shared data is considered an <em>output</em> of the source, and an <em>input</em> of the target. An output cannot be modified after the source outputs it. An input is solely owned by the target thread. To some extent, the input/output metaphor is similar to the messaging metaphor.</p><p>By avoiding sharing, we avoid the difficulties of managing shared lifetimes. The drawbacks are more memory usage and more CPU time to copy data.</p><h3 id="reference-counting"><strong>Reference counting</strong></h3><p>Reference counting is widely adopted as a native feature in many programming languages. For each piece of data, we keep a count of how many outstanding references there are. The data dies when there are no more references out there.</p><p>The advantage of reference counting is that it can be fully automatic. The programmer no longer needs to manage lifetime manually. The drawback is that it is usually unpredictable when the underlying object dies, or who will end up cleaning up the object. This can be a problem in languages that use RAII extensively like C++. Sometimes it is important to <em>not</em> run certain deconstructors on certain threads.</p><p>Speaking of C++, <code>shared_ptr</code> is the tool that implemented the reference counting strategy. <code>unique_ptr</code> is often listed side-by-side with <code>shared_ptr</code>. They happen to correspond to the two strategies we talked about: <code>unique_ptr</code> is about message passing, while <code>shared_ptr</code> is about data sharing.</p><h3 id="carrier"><strong>Carrier</strong></h3><p><a href="https://docs.rs/more-sync/0.1.0/more_sync/struct.Carrier.html">The Carrier pattern</a> improves upon reference counting and addresses the deconstruction problem. In this pattern, there is a <code>Carrier&lt;T&gt;</code> that owns an instance of any <code>T</code>. The carrier distributes references to the owned instance. References can be passed around and maybe used in other threads, and are guaranteed to be valid. When the shutdown procedure is started, the carrier stops producing references and waits for all references it gave out. Gradually other parties drop their references after receiving the shutdown signal. After all references are dropped, the instance of <code>T</code> is no longer shared, but solely owned by the carrier. We can then drop the instance or run cleanups that require an owned instance.</p><h3 id="careful-planning"><strong>Careful planning</strong></h3><p>There are really clever ways to manage object lifetime by planning very carefully. For example, for each function, we should be very clear about who is responsible for cleaning up the objects involved in the function call. While it can be done, I would not recommend implementing those cleverness regularly. Try to fit your use cases into one of the regular ones. If nothing works, maybe you should roll your own.</p><h3 id="thread-safety"><strong>Thread Safety</strong></h3><p>Note none of these strategies help with thread safety of the object being shared. Thread safety is about</p><ul><li>If one thread reads the shared data, could it see partially updated / invalid data? Could the data change while the thread is executing?</li><li>If one thread writes the shared data, could its writes be observed partially by other threads? Could its writes be overridden partially by other threads?</li></ul><p>Even the copying strategy is vulnerable to objects that are not thread safe. That is because objects can have references to other objects that are not deeply copied. The inner objects are still shared by all threads, although each of the outer objects has only one owner.</p><p>Generally speaking, an object that does not have mutable internal state is safe to share between threads. Any immutable reference to such objects is safe to send to another thread. If you are familiar with Rust, I believe those are the definitions of <code>Sync</code> and <code>Send</code>.</p><h3 id="conclusion"><strong>Conclusion</strong></h3><p>Managing lifetimes across threads is hard. There are clever ways to coordinate between threads. By preferring single ownership, we found three simple but powerful strategies for special use cases.</p>
			</section>

			<section class="post-footer">

				<div class="post-share">
					<span class="post-info-label">Share</span>
					<a title="Twitter" aria-label="Twitter" class="twitter" href="https://twitter.com/share?text=Object lifetime and threading&url=https://www.ditsing.com/object-lifetime-and-threading/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
						<i class="icon icon-twitter" aria-hidden="true"></i>
					</a>
					<a title="Facebook" aria-label="Facebook" class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.ditsing.com/object-lifetime-and-threading/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
						<i class="icon icon-facebook" aria-hidden="true"></i>
					</a>
					<a title="LinkedIn" aria-label="LinkedIn" class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.ditsing.com/object-lifetime-and-threading//&amp;title=Object lifetime and threading" onclick="window.open(this.href, 'linkedin-share', 'width=930,height=720');return false;">
						<i class="icon icon-linkedin" aria-hidden="true"></i>
					</a>
					<a title="Email" aria-label="Email" class="email" href="mailto:?subject=Object lifetime and threading&amp;body=https://www.ditsing.com/object-lifetime-and-threading/">
						<i class="icon icon-mail" aria-hidden="true"></i>
					</a>
				</div>

				<aside class="post-tags">
					<span class="post-info-label">Topic</span>
					<a href="/tag/lifetime/">Lifetime</a>
				</aside>

			</section>


			<section class="post-comments">
				<a id="show-disqus" class="post-comments-activate">Show Comments</a>
			   <div id="disqus_thread"></div>
			</section>


			<aside class="post-nav">

					<a class="post-nav-next" href="/doctype-changes-css-behavior/">
						<section class="post-nav-teaser">
							<i class="icon icon-arrow-left" aria-label="Next post"></i>
							<h2 class="post-nav-title">DOCTYPE changes CSS behavior</h2>
							<p class="post-nav-excerpt">It seems CSS behaves differently with and without the DOCTYPE comment&hellip;</p>
							<p class="post-nav-meta"><time datetime="27-09-2021">27 Sep 2021</time></p>
						</section>
					</a>

					<a class="post-nav-prev" href="/object-lifetime-and-ownership/">
						<section class="post-nav-teaser">
							<i class="icon icon-arrow-right" aria-label="Previous post"></i>
							<h2 class="post-nav-title">Object lifetime and ownership</h2>
							<p class="post-nav-excerpt">Before learning Rust, I never thought about object lifetime and ownership that&hellip;</p>
							<p class="post-nav-meta"><time datetime="08-09-2021">08 Sep 2021</time></p>
						</section>
					</a>
				<div class="clear"></div>
			</aside>

		</div>
	</article>
</main>





		<div class="search-wrapper">
			<div class="search">
		    <form class="search-form">
          <input class="search-field" type="text" placeholder="Search …">
          <button class="search-button" type="submit">
						<i class="icon icon-search" aria-hidden="true"></i>
					</button>
		    </form>
				<div class="popular-wrapper">
					<h4 class="popular-title">Topics</h4>
					<span class="popular-tags post-tags">
								<a href='/tag/cn/'>中文: 2</a>
								<a href='/tag/raft/'>Raft: 2</a>
								<a href='/tag/lifetime/'>Lifetime: 2</a>
								<a href='/tag/gong-zuo/'>工作: 1</a>
					</span>
				</div>
				<div class="search-result"></div>
			</div>
			<button class="search-wrapper-close" aria-label="Close"></button>
		</div>

		<div class="nav-footer">
			<nav class="nav-wrapper" aria-label="Footer">
				<span class="nav-copy">顿 &copy; 2022  <a class="nav-rss" title="RSS" href="https://www.ditsing.com/rss/" target="_blank"><i class="icon icon-rss" aria-hidden="true"></i></a></span>
				<span class="nav-credits">Published with <a href="https://ghost.org">Ghost</a> &bull; Theme <a href="https://github.com/zutrinken/attila">Attila</a> &bull; <a class="menu-item js-theme" href="#" data-system="System theme" data-dark="Dark theme" data-light="Light theme"><span class="theme-icon"></span><span class="theme-text">System theme</span> </a> </span>
			</nav>
		</div>

	</section>

	<script type="text/javascript" src="/assets/js/script.js?v=b23e0a0900"></script>

	<script>
  $(document).ready(function () {
		var viewport = $(window);
		var post = $('.post-content');
		// Responsive videos with fitVids
    post.fitVids();
		// Format code blocks and add line numbers
		function codestyling() {
	    $('pre code').each(function(i, e) {
				// Code highlight
	      hljs.highlightBlock(e);
	      // No lines for plain text blocks
	      if (!$(this).hasClass('language-text')) {
	        var code = $(this);
					// Calculate amount of lines
	        var lines = code.html().split(/\n(?!$)/g).length;
	        var numbers = [];
	        if (lines > 1) {
	          lines++;
	        }
	        for (i = 1; i < lines; i++) {
	          numbers += '<span class="line" aria-hidden="true">' + i + '</span>';
	        }
	        code.parent().append('<div class="lines">' + numbers + '</div>');
	      }
	    });
	  }
	  codestyling();
		// Reading progress bar on window top
	  function readingProgress() {
			var postBottom = post.offset().top + post.height();
			var viewportHeight = viewport.height();
      var progress = 100 - (((postBottom - (viewport.scrollTop() + viewportHeight) + viewportHeight / 3) / (postBottom - viewportHeight + viewportHeight / 3)) * 100);
      $('.progress-bar').css('width', progress + '%');
      (progress > 100) ? $('.progress-container').addClass('complete'): $('.progress-container').removeClass('complete');
	  }
	  readingProgress();
		// Trigger reading progress
	  viewport.on({
	    'scroll': function() {
	      readingProgress();
	    },
	    'resize': function() {
	      readingProgress();
	    },
	    'orientationchange': function() {
	      readingProgress();
	    }
	  });

  });
</script>


	

</body>
</html>
